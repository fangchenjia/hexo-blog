---
title: 重绘与回流
toc: true
comments: true
tags:
  - html
categories:
  - html
description:
  - 游览器的组成以及什么是重绘，什么是回流
keywords:
  - 重绘
  - 回流
  - html
  - 重排
abbrlink: 9779b982
date: 2021-01-27 15:51:42
updated: 2021-01-27 15:51:42
---

# 浏览器的工作原理

## 浏览器的组成

<!-- more -->

![浏览器的组成](https://myblog-1303177382.cos.ap-chongqing.myqcloud.com/blogpostimg/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/How-browsers-work1.png)

- 用户界面－ 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分
- 浏览器引擎－ 用来查询及操作渲染引擎的接口
- 渲染引擎（浏览器内核）－ 用来显示请求的内容，例如，如果请求内容为 html，它负责解析 html 及 css，并将解析后的结果显示出来
- 网络－ 用来完成网络调用，例如 http 请求，它具有平台无关的接口，可以在不同平台上工作
- UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口
- JS 解释器－ 用来解释执行 JS 代码
- 数据存储－ 属于持久层，浏览器需要在硬盘中保存类似 cookie 的各种数据，HTML5 定义了 Storage 技术，这是一种轻量级完整的客户端存储技术

## 主流的渲染引擎

> 浏览器的渲染引擎也叫排版引擎，或者是**浏览器内核**

主流的 渲染引擎 有

- **Chrome 浏览器**: Blink 引擎（WebKit 的一个分支）。
- **Safari 浏览器**: WebKit 引擎，windows 版本 2008 年 3 月 18 日推出正式版，但苹果已于 2012 年 7 月 25 日停止开发 Windows 版的 Safari。
- **FireFox 浏览器**: Gecko 引擎。
- **Opera 浏览器**: Blink 引擎(早期版使用 Presto 引擎）。
- **Internet Explorer 浏览器**: Trident 引擎 。
- **Microsoft Edge 浏览器**: EdgeHTML 引擎（Trident 的一个分支）。

## 渲染引擎工作原理

渲染引擎解析的基本流程：

```
1. 解析HTML构建Dom树，DOM 是W3C组织推荐的处理可扩展置标语言的标准编程接口。
2. 构建渲染树，渲染树并不等同于Dom树，因为像`head`标签 或 `display: none`这样的元素就没有必要放到渲染树中了，但是它们在Dom树中。
3. 对渲染树进行布局，定位坐标和大小、确定是否换行、确定position、overflow、z-index等等，这个过程叫`layout` 或 `reflow`，即回流。
4. 绘制渲染树，调用操作系统底层API(UI Backend)进行绘图操作。
```

![](https://myblog-1303177382.cos.ap-chongqing.myqcloud.com/blogpostimg/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/flow.png)

**webkit 内核工作流程**

![](https://myblog-1303177382.cos.ap-chongqing.myqcloud.com/blogpostimg/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/webkitflow.png)

**gecko 内核工作流程**

![](https://myblog-1303177382.cos.ap-chongqing.myqcloud.com/blogpostimg/%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/gecko.jpg)

结论：浏览器能够解析 HTML 文件，并且显示到页面中。所以我们写的文件能够使用浏览器打开并且能够看到效果。

## 性能优化：重绘与回流（重排）

> 回流（reflow）与重绘（repaint），在性能优化的时候，经常会提起，因为涉及到浏览器底层的渲染，所以掌握的童鞋并不多，但是面试经常被提及。

`回流(reflow)`:当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。

`重绘(repaint)`：当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。

1. 每个页面至少需要一次回流+重绘。
2. 回流必将引起重绘

回流什么时候发生？

1、添加或者删除可见的 DOM 元素；

2、元素位置改变；

3、元素尺寸改变——边距、填充、边框、宽度和高度

4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；

5、页面渲染初始化；

6、浏览器窗口尺寸改变——resize 事件发生时；

```js
var s = document.body.style;
s.padding = "2px"; // 回流+重绘
s.border = "1px solid red"; // 再一次 回流+重绘
s.color = "blue"; // 再一次重绘
s.backgroundColor = "#ccc"; // 再一次 重绘
s.fontSize = "14px"; // 再一次 回流+重绘
// 添加node，再一次 回流+重绘
document.body.appendChild(document.createTextNode("abc!"));
```

- 如何性能优化? 尽量减少重绘与回流的次数

  - 直接使用 className 修改样式，少用 style 设置样式

  - 让要操作的元素进行”离线处理”，处理完后一起更新

    - 使用 DocumentFragment 进行缓存操作,引发一次回流和重绘
    - 使用 display:none 技术，只引发两次回流和重绘;

  - 将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow 。

  - **完成功能是前提，在完成功能的情况下想着优化代码**

```javascript
var pNode,
  fragment = document.createDocumentFragment();
//动态创建20个p标签，先用DocumentFragment 对象来缓存
for (var i = 0; i < 20; i++) {
  pNode = document.createElement("p");
  pNode.innerHTML = i;
  fragment.appendChild(pNode);
}
document.body.appendChild(fragment);
```
