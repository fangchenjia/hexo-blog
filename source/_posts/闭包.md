---
title: 闭包
toc: true
comments: true
tags:
  - JavaScript
categories:
  - JavaScript
description:
  - 闭包（closure）是JavaScript的一个特色，很多高级的应用都要依靠闭包来实现。
abbrlink: f9636392
date: 2020-11-09 10:32:17
updated: 2020-11-09 10:32:17
---

# 闭包

## 闭包的基本概念

`闭包（closure）`是 JavaScript 的一个特色，很多高级的应用都要依靠闭包来实现。

<!-- more -->

### 作用域

在 js 中，函数会形成函数作用域，在函数内部可以直接访问全局变量

```javascript
var str = "Mr.Fang";
function fn() {
  console.log(str); //访问全局变量
}
fn(); //Mr.Fang
```

在函数外部却无法访问函数内部的变量

```javascript
function fn() {
  var str = "Mr.Fang";
}
fn();
console.log(str); //报错 str is not defined
```

怎么才能获取到函数内部的变量？

### 作用域链

在函数内部有一个函数，那么函数内部的函数是可以访问到外部函数的变量的。

解决方法：

```javascript
function fn() {
  var str = "Mr.Fang";
  function f2() {
    console.log(str);
  }
  f2();
}
fn();
```

在上述代码中，fn 中定义的所有变量，对于 f2 函数都来都是可以访问的。但是 f2 在函数的内部，我们要在外部访问到 f2 这个函数

```javascript
function fn() {
  var str = "Mr.Fang";
  function f2() {
    console.log(str);
  }
  return f2;
}
var result = fn();
result(); // "Mr.Fang"
```

### 闭包的概念

> 闭包是函数和声明该函数的词法环境的组合。

在 JavaScript 中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，产生闭包。

**闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用 **

产生闭包的条件

```javascript
当内部函数访问了外部函数的变量的时候，就会形成闭包。
```

闭包的作用：

1. 私有变量，保护数据安全
2. 持久化维持数据

## 闭包的应用

### 计数器案例

需求：统计一个函数的调用次数

```javascript
var count = 0;
function fn() {
  count++;
  console.log("调用次数是" + count);
}
fn();
count = 100; //count是全局变量，在外部可被修改
fn();
fn();
```

缺点：count 是全局变量，不安全。

可以使用闭包解决这个问题

```javascript
function outer() {
  var count = 0; // 私有变量, 将count保护起来了
  function add() {
    count++;
    console.log("当前count：" + count);
  }
  return add;
}

var result = outer();
result();
```

## 闭包存在的问题

> 闭包占用的内存是不会被释放的，因此，如果滥用闭包，会造成内存泄漏的问题。

### js 的垃圾回收机制

<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">可参考文档</a>

- 内存：计算机中所有程序的运行都是在`内存`中进行的，因此内存的性能对计算机的影响非常大，运行程序需要消耗内存，当程序结束时，内存会得到释放。
- javascript 分配内存：当我们定义变量，javascript 需要分配内存存储数据。无论是值类型或者是引用类型，都需要存储在内存中。
- 垃圾回收：当代码执行结束，分配的内存已经不需要了，这时候需要将内存进行回收，在 javascript 语言中，`垃圾回收机器`会帮我们回收`不再需要使用`的内存。

#### 引用记数法清除

引用记数垃圾收集：如果没有引用指向某个对象（或者是函数作用域），那么这个对象或者函数作用域就会被垃圾回收机制回收。

```javascript
var o = {
  name: "Mr.fang",
};
//对象被o变量引用  ，引用记数1
var obj = o; //变量被o和obj引用，引用记数2

o = 1; //o不在引用对象了， 引用记数1
obj = null; //obj不在引用对象了，引用记数0，可以被垃圾回收了。
```

#### 标记清除法清除

使用引用计数法进行垃圾回收的时候，会出现循环引用导致内存泄漏的问题。因此现代的浏览器都采用标记清除法来进行垃圾回收。

这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象 Window）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。

**从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。**

### 闭包占用内存释放

```javascript
function outer() {
  var count = 0;

  function fn() {
    count++;
    console.log("执行次数:" + count);
  }
  return fn;
}

var result = outer();
result();
result = null; //当函数fn没有被变量引用了，那么函数fn就会被回收，函数fn一旦被回收，那么outer调用形成的作用域也就得到了释放。
```

本文是记录于黑马课程的笔记，仅用于个人学习。
