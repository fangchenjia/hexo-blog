---
title: 封装一个拖拽对象
toc: true
comments: true
tags:
  - JavaScript
categories:
  - JavaScript
description:
  - 最近发现时不时需要实现拖拽的功能，所以简单封装一个拖拽类
abbrlink: 595152f9
date: 2021-06-12 12:24:48
updated: 2021-06-12 12:24:48
---

<!-- more -->

# 基本实现

```js
let box = document.querySelector("#box");
let curMouse = {}; //当前鼠标位置信息
let startMouse = {}; //按下时鼠标位置信息
let startBox = {}; //按下时box位置信息
let moveFn = function (e2) {
  // 移动函数
  curMouse = {
    x: e2.clientX,
    y: e2.clientY,
  };
  let distance = {
    x: curMouse.x - startMouse.x,
    y: curMouse.y - startMouse.y,
  };
  operateCss(box, "top", startBox.y + distance.y + "px");
  operateCss(box, "left", startBox.x + distance.x + "px");
  //console.log(operateCss(box,'top'))
  //console.log(startMouse,curMouse)
};
//操作css的函数
let operateCss = function (el, attr, value) {
  if (!value) {
    return getComputedStyle(el, null)[attr];
  } else {
    el.style[attr] = value;
  }
};
box.addEventListener("mousedown", function (e) {
  startBox = {
    x: e.target.offsetLeft,
    y: e.target.offsetTop,
  };
  startMouse = {
    x: e.clientX,
    y: e.clientY,
  };
  document.addEventListener("mousemove", moveFn);
  //鼠标松开后移除移动事件
  document.addEventListener("mouseup", function () {
    document.removeEventListener("mousemove", moveFn, { once: true });
  });
});
```

# 简单封装一下

```js
class Drag {
  #startMouse = { x: 0, y: 0 }; //鼠标初始位置
  #curMouse = { x: 0, y: 0 }; //鼠标当前位置
  constructor(el) {
    this.el = el;
    this.position = { x: 0, y: 0 }; //el left以及top值
    this.start();
  }
  start() {
    this.el.addEventListener("mousedown", (e) => {
      //设置el的left以及top值
      this.position.x = e.target.offsetLeft;
      this.position.y = e.target.offsetTop;
      this.#startMouse.x = e.clientX;
      this.#startMouse.y = e.clientY;
      //鼠标移动函数
      let moveFn = (e) => {
        this.#curMouse.x = e.clientX;
        this.#curMouse.y = e.clientY;
        this.move();
      };
      document.addEventListener("mousemove", moveFn);
      document.addEventListener(
        "mouseup",
        (e) => {
          document.removeEventListener("mousemove", moveFn);
        },
        { once: true }
      );
    });
  }
  move() {
    let disX = this.#curMouse.x - this.#startMouse.x;
    let disY = this.#curMouse.y - this.#startMouse.y;
    this.el.style.left = this.position.x + disX + "px";
    this.el.style.top = this.position.y + disY + "px";
  }
}
let box = document.querySelector("#box");
let baseDrag = new Drag(box);
```

# 再进行高级一点的封装

> 因为可能有多种拖拽效果，每种拖拽效果都有相同的代码，所以得先实现一个基本类

## 首先实现一个简单的事件池

```js
class Event {
  events = {}; //事件池
  on(eventName, fn) {
    //添加一个事件处理
    !this.events[eventName] && (this.events[eventName] = []);
    this.events[eventName].push(fn);
  }
  off(eventName, fn) {
    //删除一个事件处理
    if (!this.events[eventName]) {
      return;
    }
    this.events[eventName] = this.events[eventName].filter(
      (item) => item != fn
    );
  }
  dispatch(eventName) {
    if (!this.events[eventName]) {
      return;
    }
    this.events[eventName].forEach((item) => {
      item.call(this);
    });
  }
}
```

## 实现最基本的拖拽类

> 该类不作拖拽处理，只是保存一些基本的位置信息用于子类不同的拖拽处理

```js
class BaseDrag extends Event {
  startMouse = { x: 0, y: 0 }; //鼠标初始位置
  curMouse = { x: 0, y: 0 }; //鼠标当前位置
  constructor(el) {
    super();
    this.el = el;
    this.position = { x: 0, y: 0 }; //el left以及top值
    this.start();
  }
  start() {
    this.el.addEventListener("mousedown", (e) => {
      e.preventDefault();
      //设置el的left以及top值
      this.position.x = e.target.offsetLeft;
      this.position.y = e.target.offsetTop;
      this.startMouse.x = e.clientX;
      this.startMouse.y = e.clientY;
      //鼠标移动函数
      let moveFn = (e) => {
        this.curMouse.x = e.clientX;
        this.curMouse.y = e.clientY;
        this.move(e);
      };
      this.dispatch("dragstart");
      document.addEventListener("mousemove", moveFn);
      document.addEventListener(
        "mouseup",
        (e) => {
          document.removeEventListener("mousemove", moveFn);
          this.end(e);
        },
        { once: true }
      );
    });
  }
  move(e) {
    this.dispatch("drag");
  }
  end(e) {
    this.dispatch("dragend");
  }
}
```

## 一个普通的拖拽类

```js
//普通的拖拽
class Drag extends BaseDrag {
  constructor(el) {
    super(el);
    //添加拖拽处理
    this.on("drag", () => {
      let disX = this.curMouse.x - this.startMouse.x;
      let disY = this.curMouse.y - this.startMouse.y;
      this.el.style.left = this.position.x + disX + "px";
      this.el.style.top = this.position.y + disY + "px";
    });
  }
}
let box = document.querySelector("#box");
let drag = new Drag(box);
```

## 一个拖拽过程中变透明，且拖拽完成时才发生移动的拖拽类

```js
//拖拽时变透明的拖拽
class Drag2 extends BaseDrag {
  constructor(el) {
    super(el);
    this.on("dragstart", () => {
      this.cloneEl = this.el.cloneNode();
      this.el.parentNode.appendChild(this.cloneEl);
      this.el.style.opacity = ".5";
    });
    this.on("drag", () => {
      let disX = this.curMouse.x - this.startMouse.x;
      let disY = this.curMouse.y - this.startMouse.y;
      this.el.style.left = this.position.x + disX + "px";
      this.el.style.top = this.position.y + disY + "px";
    });
    this.on("dragend", () => {
      this.el.parentNode.removeChild(this.cloneEl);
      this.cloneEl = null;
      this.el.style.opacity = "1";
    });
  }
}
let box2 = document.querySelector("#box2");
let drag2 = new Drag2(box2);
```

这样虽然代码稍微复杂一点，但可拓展性强。
