---
title: 微信小程序
toc: true
comments: true
tags:
  - 微信小程序
categories:
  - 微信小程序
description:
  - 微信小程序笔记
keywords:
  - 微信小程序笔记
abbrlink: 4618cb0a
date: 2021-02-24 19:39:11
updated: 2021-02-24 19:39:11
---

# 微信小程序介绍

## 微信小程序简介

> 小程序是一种新型的轻量的开发技术，"微信之父" 张小龙是这样定义小程序的：

【优点】

- 用完即走，无需下载，安装，注册，卸载等操作
- 基于微信，小程序可以非常便捷的获取和传播
- 每个小程序都有 10 亿的潜在用户

【缺点】

- 功能受限于微信，只能在微信内部使用
- 用户体验没有原生 app 好，依赖于网速

【注意点】

**小程序不是 web 开发，类似于 web（对前端开发人员友好）**

## 注册小程序

- [微信公众平台](https://mp.weixin.qq.com/)
- 进入后台：开发 -> 开发设置 -> 拿到 AppID（创建小程序项目使用）

## 微信开发者工具

- [安装](https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html)

- [开发者工具使用](https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html)

- 说明：第一次使用工具需要使用`注册小程序的微信`扫码登录

- 创建小程序项目：

  - 1 项目目录：使用空目录
  - 2 AppID： 使用注册后获取到的 AppID
  - 3 项目名称：非小程序名称，可以是任意名称

## 小程序项目结构

- [目录结构](https://developers.weixin.qq.com/miniprogram/dev/framework/structure.html)

```html
pages/ ---------------- 页面（组件），所有页面都应该放到这个目录中 index/
------------- index文件夹 index.js ---------- index页面的逻辑代码 index.wxml
-------- index页面的HTML结构 index.wxss -------- index页面的CSS样式 index.json
-------- 页面配置（可选） utils/ ---------------- 公共工具（函数） app.js
---------------- 逻辑 app.json --------------
全局配置（包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等）
app.wxss -------------- 全局样式（CSS） project.config.json ---
开发工具配置（例如ES6转ES5、界面颜色、编译配置等） sitemap.json ---------
用来配置小程序及其页面是否允许被微信索引。
```

# 微信小程序配置

## 全局配置

> `app.json`文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。

[全局配置文档](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html)

### pages 基本使用

> 用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径+文件名 信息。

```js
app.json 配置说明：
1 所有的页面都需要配置到 `pages` 配置项中
2 `pages` 数组的第一项表示进入小程序要展示的页面
{
"pages": [
    "pages/index/index",
    "pages/logs/logs"
  ]
}
```

window 的基本使用

> 用于设置小程序的状态栏、导航条、标题、窗口背景色。

```js
{
  "window":{
    "navigationBarBackgroundColor": "#ffffff",  导航背景颜色
    "navigationBarTextStyle": "black",   导航字体颜色
    "navigationBarTitleText": "微信接口功能演示",   导航标题
    "enablePullDownRefresh": true 是否支持下拉
    "backgroundColor": "#eeeeee", 窗口背景颜色(下拉)
  }
}
```

### tabBar 的基本使用

> 如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。

- tabBar 中的 list 是一个数组，只能配置最少 2 个、最多 5 个 tab，tab 按数组的顺序排序
- 当设置 position 为 top 时，将不会显示 icon
- 注意：没有出现在`tabBar.list`的`pagePath`页面不展示标签栏

```js
"tabBar": {
    "color": "#fff",       文字默认原色
    "selectedColor": "#000",   选中时的文字颜色
    "backgroundColor": "#f91", tab背景色
    "borderStyle": "white",   tab上边框颜色
    "position": "bottom",  tab位置
    "list": [               tab项
      {
        "pagePath": "pages/login/login",  对应页面
        "text": "登录",                    提示文本
        "iconPath": "/assets/profile.png",  默认图标
        "selectedIconPath": "/assets/profile-actived.png" 选中图标
      },
      {
        "pagePath": "pages/index/index",
        "text": "首页",
        "iconPath": "/assets/home.png",
        "selectedIconPath": "/assets/home-actived.png"
      }
    ]
  }
```

### 其他配置

## 页面配置

> 每一个小程序页面也可以使用`.json`文件来对本页面的窗口表现进行配置。
>
> 页面的配置只能设置 `app.json` 中部分 `window` 配置项的内容，页面中配置项会覆盖 `app.json` 的 `window` 中相同的配置项。

[文档地址](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE)

# 微信小程序语法

## WXML

> 从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中 `HTML` 是用来描述当前这个页面的结构，`CSS` 用来描述页面的样子，`JS` 通常是用来处理这个页面和用户的交互。
>
> 同样道理，在小程序中也有同样的角色，其中 `WXML` 充当的就是类似 `HTML` 的角色。打开 `pages/index/index.wxml`，你会看到以下的内容:

[文档地址](https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/code.html)

## WXSS

WXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。

WXSS 用来决定 WXML 的组件应该怎么显示。

为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。

与 CSS 相比，WXSS 扩展的特性有：

- 尺寸单位
- 样式导入

[文档地址](https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/code.html)

# 小程序 js 操作

## 数据绑定

- WXML 中的动态数据均来自对应 Page 的 `data`

```js
1. 在小程序中，通过{{}}来显示data中的数据
2. 在小程序中，{{}}也可以出现表达式,比如三元, 对象,数组
3. 在插值表达式中不能调用方法
4. 可以在属性中使用插值表达式
```

```html
<view>{{msg}}</view>
<view>{{msg + '11'}}</view>
<view>{{msg.toUpperCase()}}</view>

<view><checkbox checked="{{isChecked}}"></checkbox></view>
<view><checkbox checked="{{true}}"></checkbox></view>
```

## 条件渲染

- wx:if

```html
<view wx:if="{{ isLoading }}">
  <text>数据加载中...</text>
</view>
<!-- <view wx:elif=""></view> -->
<view wx:else>
  <text>搞定啦~</text>
</view>

<!-- 隐藏多个元素，不改变 wxml的层级结构 -->
<block wx:if="{{ isLoading }}">
  <text>小明</text>
  <text>小红</text>
</block>
```

- hidden

```html
<view hidden="{{ isLoading }}">
  <text>搞定啦~</text>
</view>
```

`wx:if` 和 `hidden`的区别:

因为 `wx:if` 之中的模板也可能包含数据绑定，所以当 `wx:if` 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。

同时 `wx:if` 也是**惰性的**，如果在初始渲染条件为 `false`，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。

相比之下，`hidden` 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。

一般来说，`wx:if` 有更高的切换消耗而 `hidden` 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 `hidden` 更好，如果在运行时条件不大可能改变则 `wx:if` 较好。

## 列表渲染

- `wx:for`：遍历数组，在元素中通过`index`获取索引号，通过`item`获取当前项
- `wx:for-index="idx"`：替换默认的 index
- `wx:for-item="it"`：替换默认的 item
- 注意：**遍历数组元素的时候，需要添加`wx:key`属性，来提高渲染性能**

```html
<view
  wx:for="{{ list }}"
  wx:for-index="idx"
  wx:for-item="itemName"
  wx:key="itemName.id"
>
  {{idx}}: {{itemName.message}}
</view>
```

**注意：** 花括号和引号之间如果有空格，将最终被解析成为字符串

```html
<view wx:for="{{[1,2,3]}} "> {{item}} </view>
```

等同于

```html
<view wx:for="{{[1,2,3] + ' '}}"> {{item}} </view>
```

## 事件处理

- 绑定事件：1 `bindtap` 2 `catchtap`
- 说明：bind 事件绑定不会阻止冒泡事件向上冒泡，catch 事件绑定可以阻止冒泡事件向上冒泡
- 说明：通过标签的自定义属性`data-*`，实现给事件“传递”参数

```js
<button bindtap="sayHi" data-msg="test">
  点我吧
</button>;

Page({
  sayHi(event) {
    console.log("单击事件触发了~", event.currentTarget.dataset.msg);
  },
});
```

## 数据操作

- [setData](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html)
- `setData()`：更新数据
  - 说明：将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）
  - 1 修改 data 中的数据
  - 2 更新视图，也就是说：视图中使用该数据的地方会重新渲染

```js
this.setData({
  name: "jack",
});
```

- 文本框操作：

```js
<input value="{{ input }}" bindinput="inputChangeHandle" />;

Page({
  inputChangeHandle: function (e) {
    this.setData({ input: e.detail.value });
  },
});
```

# 注册事件

### 绑定事件基本用法

```html
<!-- 
  在小程序注册事件：
  bind+事件名称=事件函数
-->
<button type="primary" bindtap="tapFn">点我注册事件</button>
```

js

```js
  // js中提供方法，不是在methods中，而是直接写在对象中
  tapFn () {
    console.log('tap事件触发了')
  }
  // js中提供方法，不是在methods中，而是直接写在对象中
  tapFn () {
    console.log('tap事件触发了')
    // 如果打印msg数据,必须通过this.data.xxx进行访问
    console.log(this.data.msg)
  }
```

### 冒泡事件与非冒泡事件

```html
<!-- 
  在小程序注册事件：
  bind+事件名称=事件函数  注册的事件会冒泡
  catch+事件名称=事件函数 注册的事件不会冒泡
-->
<view bindtap="parentFn">
  <button type="primary" bindtap="tapFn">点我注册事件</button>
  <button type="primary" catchtap="tapFn">点我注册事件</button>
</view>
```

**一般来说，注册事件不用管是否冒泡，因此注册事件就用 bind 来绑定就行了**

## 总结

```js
1. 能够绑定事件
2. 能够使用bind和catch绑定事件
3. 能够获取data中的数据
```

# 绑定事件-传递参数

结构

```html
<view>
  <!-- 想要传递参数，需要通过data-xxx添加自定义属性 -->
  <button bindtap="del" data-id="1">{{item.name}}</button>
</view>
```

js

```js
// 问题，如何获取到id值
// 通过event.currentTarget.dataset.id 就可以获取到参数
del(event) {
    console.log('哈哈')
    console.log(event.currentTarget.dataset.id)
}
```

# setData 同步数据到视图

结构

```html
<view>{{msg}}</view> <button bindtap="change">改变msg</button>
```

js

```js
change () {
    this.data.msg = '哈哈哈'
}
```

**小程序不是双向数据绑定**

**注意点：直接修改 this.data 而不调用 this.setData， 是无法改变页面的状态的，还会造成数据不一致。**

**如果想要修改 this.data 中的数据，并且希望页面状态也跟着改变，需要调用 setData 方法**

js

```js
change () {
  // 修改data中的数据，需要使用this.setData方法
  this.setData({
    msg: '哈哈'
  })
}
```

# 模拟双向数据绑定

- 准备 html

```html
<text>{{msg}}</text>
<input value="{{msg}}"></input>
<button bindtap="change">修改数据</button>
```

- 逻辑层同步到视图层

```js
Page({
  change() {
    this.data.msg = "你好";
  },
});
```

- 视图层同步到逻辑层

```json
注册事件
<input bindinput="set" value="{{msg}}"></input>

Page({
    set(e) {
        console.log(e.detail.value)
        this.setData({
            msg: e.detail.value
        })
    }
})
```

### 列表展示

js

```js
  data: {
    list: [
      { id: 1, name: '赵云', price: '18888' },
      { id: 2, name: '马超', price: '13888' },
      { id: 3, name: '黄忠', price: '8888' }
    ]
  },
```

html

```html
<view>
  <view wx:for="{{list}}" wx:key="id"> {{item.name}}----{{item.price}} </view>
</view>
```

### 添加功能

添加功能

```html
<button bindtap="add">添加一条记录</button>
```

js

```js
add () {
    this.data.list.push({
        id: 4,
        name: '刘备',
        price: 18888
    })
    this.setData(this.data)
}
```

### 删除功能

结构

```html
<view>
  <view wx:for="{{list}}" wx:key="id" bindtap="del" data-id="{{item.id}}">
    {{item.name}}----{{item.price}}
  </view>

  <button bindtap="add">添加一条记录</button>
</view>
```

js

```js
  del(e) {
    // 获取到id值
    let id = e.currentTarget.dataset.id
    let idx = this.data.list.findIndex(item => item.id === id)
    this.data.list.splice(idx, 1)
    this.setData(this.data)
  }
```

# 小程序生命周期

- 两个生命周期：1 应用生命周期 2 页面生命周期
- [app 生命周期](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html)
- [页面 生命周期](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html)

```js
App() 函数用来注册一个小程序。接受一个 Object 参数，其指定小程序的生命周期回调等。
App() 必须在 app.js 中调用，必须调用且只能调用一次。不然会出现无法预期的后果。

讲解常见的小程序声明周期函数
// App函数调用用于初始化一个小程序，参数是一个对象
  // 可以在对象中指定小程序的生命周期回调函数
  onLaunch () {
    // 小程序初始化完成时触发，全局只触发一次。
    // 比如登录的代码，或者用户信息的代码，都可以放到onLaunch中
    console.log('onLaunch','小程序初始化完成了')
  },

  onShow() {
    // 生命周期回调—监听小程序显示，或从后台进入前台显示时
    console.log('onShow','当小程序显示的时候')
  },
  onHide () {
    // 小程序从前台进入后台时
    console.log('onHide', '当小程序隐藏的时候')
  },
```

# 小程序-页面生命周期

- [页面 生命周期](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html)

```js
1. Page(Object) 函数用来注册一个页面。接受一个 Object 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。

  // onLoad生命周期函数 页面加载时触发。一个页面只会调用一次
  onLoad () {
    console.log('onLoad', '页面加载时触发。一个页面只会调用一次')
  },
  onReady: function() {
    console.log('onRead', '页面初次渲染完成时触发。一个页面只会调用一次，')
  },
  onShow() {
    console.log('onshow', '页面显示时触发，多次')
  },
  onHide() {
	console.log('onshow', '页面隐藏时触发，多次')
  }
  onUnload: function() {
    console.log('onshow', '页面关闭时触发,一次')
  },


```
