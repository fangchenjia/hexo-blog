---
title: 函数进阶
categories: JavaScript
keywords: js 函数
tags:
  - JavaScript
abbrlink: bf60025d
date: 2020-11-04 11:54:35
---
# 函数进阶
<!--more-->

## 定义函数的三种方式

### 函数声明

```javascript
fn();//函数声明可以先调用，在声明
function fn(){
  console.log("这是函数声明")
}
```

### 函数表达式

```javascript
var fn = function() {
  console.log("这是函数表达式");  
}
fn();//函数表达式必须先声明，再调用
```
### 构造函数Function

```javascript
//函数也是对象，可以使用Function构造函数new出来
//相当于var fn = function(){}
var fn = new Function();

//语法：new Function(arg1,arg2,arg3..,body);
// 1. 所有的参数都是字符串类型。
// 2. 前面可以定义任意多个形参，最后一个参数是代码体。
var fn = new Function("alert(1111)");
fn();

var fn1 = new Function("a1", "a2", "alert(a1+a2)");
fn1(1,2);
```

## eval函数--了解

> eval的可以和new Function一样，执行字符串代码

注意：eval函数的功能非常的强大，但是实际使用的情况并不多。

- eval形式的代码难以阅读
- eval形式的代码无法打断点，因为本质还是还是一个字符串
- 在浏览器端执行任意的 JavaScript会带来潜在的安全风险，恶意的JavaScript代码可能会破坏应用，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的代码注入）
  
## 函数的四种调用模式

> 根据函数内部this的指向不同，可以将函数的调用模式分成4种

1. 函数调用模式
2. 方法调用模式
3. 构造函数调用模式
4. 上下文调用模式（借用方法模式）

```javascript
函数：当一个函数不是一个对象的属性时，我们称之为函数。
方法：当一个函数被保存为对象的一个属性时，我们称之为方法。
```

### 函数调用模式

<font color="red">如果一个函数不是一个对象的属性时，就是被当做一个函数来进行调用的。此时this指向了window</font>

```javascript
function fn(){
  console.log(this);//指向window
}
fn();
```



### 方法调用模式

<font color="red">当一个函数被保存为对象的一个属性时，我们称之为一个方法。当一个方法被调用时，this被绑定到当前对象</font>

```javascript
var obj = {
  sayHi:function(){
    console.log(this);//在方法调用模式中，this指向调用当前方法的对象。
  }
}
obj.sayHi();
```



### 构造函数调用模式

<font color="red">如果函数是通过new关键字进行调用的，此时this被绑定到创建出来的新对象上。</font>

```javascript
function Person(){
  console.log(this);
}
Person();//this指向什么？
var p = new Person();//this指向什么？
```

**总结：分析this的问题，主要就是区分函数的调用模式，看函数是怎么被调用的。**

+ 猜猜看：

```javascript
//分析思路：1. 看this是哪个函数的  2. 看这个函数是怎么调用的，处于什么调用模式
//题目一：
var age = 38;
var obj = {
    age: 18,
    getAge: function () {
        console.log(this.age);
    }
}

var f = obj.getAge;
f();//38


//题目二
var age = 38;
var obj = {
  age:18,
  getAge:function () {
    console.log(this.age);
    function foo(){
      console.log(this.age);
    }
    foo();
  }
}
obj.getAge(); //18 38
obj["getAge"](); //18 38


//题目三：
var length = 10;
var age = 18;
function fn() {
    console.log(this.length);
}
var arr = [fn, "222"];
fn(); //10
arr[0]();  //2

//题目四：
// 面试题5:
var length = 10

function fn() {
    console.log(this.length)
}
var obj = {
    length: 5,
    method: function (fn) {
        fn() 
        arguments[0]();
    }
}
obj.method(fn, 10, 5); //10 3
```

几种特殊的this指向

+ 定时器中的this指向了window，因为定时器的function最终是由window来调用的。
+ 事件中的this指向的是当前的元素，在事件触发的时候，浏览器让当前元素调用了function

### 上下文调用模式

> 上下文调用模式也叫方法借用模式，分为apply与call
>
> 使用方法： 函数.call() 或者 函数.apply()


#### call方法

call方法可以调用一个函数，并且可以指定这个函数的`this`指向

```javascript
//所有的函数都可以使用call进行调用
//参数1：指定函数的this，如果不传，则this指向window
//其余参数：和函数的参数列表一模一样。
//说白了，call方法也可以和()一样，进行函数调用，call方法的第一个参数可以指定函数内部的this指向。
fn.call(thisArg, arg1, arg2, arg2);
```

+ 借用对象的方法

#### 伪数组与数组

> 伪数组也叫类数组

1. 伪数组其实就是一个对象，但是跟数组一样，伪数组也会有`length`属性，也有`0,1,2,3`等属性。
2. 伪数组并没有数组的方法，不能使用`push/pop`等方法
3. 伪数组可以跟数组一样进行遍历，通过下标操作。
4. 常见的伪数组：`arguments`、`document.getElementsByTagName的返回值`、`jQuery对象`

```javascript
var arrayLike = {
  0:"张三",
  1:"李四",
  2:"王五",
  length:3
}
//伪数组可以和数组一样进行遍历
```

- 伪数组借用数组的方法

```javascript
Array.prototype.push.call(arrLike, "赵六");
Array.prototype.join.call(arrLike, "-");
```

- 将伪数组转换成真数组

```javascript
var arr = Array.prototype.slice.call(arrLike);
```

#### apply方法

`apply()`方法的作用和 `call()`方法类似，只有一个区别，就是`apply()`方法接受的是**一个包含多个参数的数组**。而`call()`方法接受的是**若干个参数的列表**

call和apply的使用场景：

+ 如果参数比较少，使用call会更加简洁
+ 如果参数存放在数组中，此时需要使用apply


#### bind方法   

**bind()**方法创建一个新的函数, 可以绑定新的函数的`this`指向

```javascript
// 返回值：新的函数
// 参数：新函数的this指向，当绑定了新函数的this指向后，无论使用何种调用模式，this都不会改变。
var newFn = fn.bind(window);
```

## 函数也是对象

> 函数是由new Function创建出来的，因此函数也是一个对象， `所有的函数都是new Function的实例`。

### 函数的原型链结构

画出下列代码的原型链结构

```javascript
//var Person = new Function();
function Person(){
  
}
```

![](https://myblog-1303177382.cos.ap-chongqing.myqcloud.com/blogpostimg/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/function.jpg)

### Function.prototype成员

- arguments：获取函数的实参，已经被废弃了，现在推荐的做法是使用函数内部可用的 `arguments`对象来访问函数的实参。 
  - （废弃的意思：已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。 ）
- length：获取形参的长度
- name：获取函数的名字，此属性不允许修改
- caller: 用于获取当前在函数是在哪个函数中调用的，已经被废弃了。
- constructor：指向当前构造函数，Function
- call：调用函数，重新指向this
- apply：调用函数，重新指向this
- bind：重新指向this，返回一个新的函数，不调用。

### 完整版原型链

> 绘制完整版原型链的目的是辅助大家理解js中对象的继承关系。

![](https://myblog-1303177382.cos.ap-chongqing.myqcloud.com/blogpostimg/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/full.png)

总结：

1. 所有函数都是new Function创建出来的，因此`所有函数.__proto__`都是`Function.prototype`
2. 所有对象都是new Object创建出来的，因此`所有对象.__proto__`都是`Object.prototyp`
