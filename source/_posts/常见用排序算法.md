---
title: 常见用排序算法
toc: true
comments: true
tags:
  - 算法
categories:
  - JavaScript
description:
  - 记录常见的排序算法
keywords:
  - 冒泡排序
  - 快速排序
  - 插入排序
  - 归并排序
abbrlink: 54be101
date: 2021-07-09 12:26:46
updated: 2021-07-09 12:26:46
---

# 排序算法

## 冒泡排序

```js
let arr = [1, 22, 4, 67, 12, 2, 3, 0, 44, 34];
function bubble(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = temp;
      }
    }
  }
  return arr;
}
bubble(arr);
console.log(arr); //[0, 1, 2, 3, 4, 12, 22, 34, 44, 67]
```

<!-- more -->

## 插入排序

```js
let arr = [1, 22, 4, 67, 12, 2, 3, 0, 44, 34];
function insertion(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i; j > 0; j--) {
      if (arr[j] < arr[j - 1]) {
        let temp = arr[j];
        arr[j] = arr[j - 1];
        arr[j - 1] = temp;
      } else {
        break;
      }
    }
  }
  return arr;
}
insertion(arr);
console.log(arr); //[0, 1, 2, 3, 4, 12, 22, 34, 44, 67]
```

## 快速排序

```js
let arr = [1, 22, 4, 67, 12, 2, 3, 0, 44, 34];
function quick(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  let middleIndex = Math.floor(arr.length / 2);
  let middle = arr.splice(middleIndex, 1)[0];
  let leftArr = [];
  let rightArr = [];
  for (let i of arr) {
    i < middle ? leftArr.push(i) : rightArr.push(i);
  }
  return quick(leftArr).concat(middle, quick(rightArr));
}
console.log(quick(arr)); //[0, 1, 2, 3, 4, 12, 22, 34, 44, 67]
```

## 归并排序

```js
let arr = [1, 22, 4, 67, 12, 2, 3, 0, 44, 34];
function merge(arr) {
  if (arr.length <= 1) {
    return;
  }
  process(arr, 0, arr.length - 1);
}
function process(arr, left, right) {
  if (left == right) {
    return;
  }
  let middle = left + Math.floor((right - left) >> 1);
  process(arr, left, middle);
  process(arr, middle + 1, right);
  processMerge(arr, left, middle, right);
}
function processMerge(arr, left, middle, right) {
  let temp = new Array(right - left + 1);
  let i = 0;
  let p1 = left;
  let p2 = middle + 1;
  while (p1 <= middle && p2 <= right) {
    temp[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
  }
  while (p1 <= middle) {
    temp[i++] = arr[p1++];
  }
  while (p2 <= right) {
    temp[i++] = arr[p2++];
  }
  for (let j = 0; j < temp.length; j++) {
    arr[j + left] = temp[j];
  }
}

merge(arr);
console.log(arr); //[0, 1, 2, 3, 4, 12, 22, 34, 44, 67]
```

## 堆排序

> 首先实现一个大根堆

```js
class Heap {
  constructor() {
    this.heapSize = 0;
    this.heapContainer = [];
  }
  push(value) {
    this.heapContainer[this.heapSize] = value;
    this.heapInsert(this.heapSize);
    this.heapSize++;
  }
  pop() {
    let max = this.heapContainer[0];
    this.heapContainer[0] = this.heapContainer[this.heapSize - 1];
    this.heapSize--;
    this.heapify(0);
    return max;
  }
  swap(num1, num2) {
    this.heapContainer[num1] =
      this.heapContainer[num1] ^ this.heapContainer[num2];
    this.heapContainer[num2] =
      this.heapContainer[num1] ^ this.heapContainer[num2];
    this.heapContainer[num1] =
      this.heapContainer[num1] ^ this.heapContainer[num2];
  }
  heapify(index) {
    //往下沉以维持大根堆的状态  index位置的元素和自己的左右节点作比较，只要小于左节点或者右节点就交换
    let leftChild = index * 2 + 1;
    while (leftChild < this.heapSize) {
      let maxOfChild =
        leftChild + 1 < this.heapSize &&
        this.heapContainer[leftChild + 1] > this.heapContainer[leftChild]
          ? leftChild + 1
          : leftChild;
      if (this.heapContainer[index] < this.heapContainer[maxOfChild]) {
        this.swap(index, maxOfChild);
        index = maxOfChild;
        leftChild = index * 2 + 1;
      } else {
        break;
      }
    }
  }
  heapInsert(index) {
    //往上浮 index位置的元素和自己父节点作比较，只要大于父节点就交换
    if (index == 0) {
      return;
    }
    while (
      this.heapContainer[index] >
      this.heapContainer[Math.floor((index - 1) / 2)]
    ) {
      this.swap(index, Math.floor((index - 1) / 2));
      index = Math.floor((index - 1) / 2);
    }
  }
}
```

> 利用实现的大根堆进行排序

```js
function heapSort(arr) {
  let heap = new Heap();
  heap.heapContainer = arr;
  heap.heapSize = arr.length;
  // 把arr变为大根堆
  for (let i = arr.length - 1; i >= 0; i--) {
    heap.heapify(i);
  }
  // 依次把堆顶最大的元素放到最后面
  while (heap.heapSize > 0) {
    heap.heapContainer[heap.heapSize - 1] = heap.pop();
  }
}

let arr = [1, 22, 4, 67, 12, 2, 3, 0, 44, 34];
heapSort(arr);
console.log(arr); // [0, 1, 2, 3, 4, 12, 22, 34, 44, 67]
```
